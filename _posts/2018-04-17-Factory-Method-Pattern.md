---
layout: post_layout
title: 工厂方法模式
time: 2018年04月17日 星期二
location: 北京
pulished: true
tag: java
excerpt_separator: "----"
---

　　最近要好好学习下java中的设计模式，那么先来了解下设计模式。

　　设计模式（Design Pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码，让代码更容易被他人理解、保证代码的可靠性。

　　总体来说设计模式分为三大类：

　　创建型模式：共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

　　结构型模式：共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

　　行为型模式：共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

　　还有两类：并发型模式和线程池模式

　　设计模式的六大原则：

　　1. 开闭原则（Open Close Principle）

　　对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类

　　2. 里氏代换原则（Liskov Substitution Principle）

　　里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

　　3. 依赖倒转原则（Dependencce Inversion Principle）

　　这个是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体

　　4. 接口隔离原则（Interface Segregation Principle）

　　这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

　　5. 迪米特法则（最少知道原则）（Demeter Principle）

　　为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

　　6. 合成复用原则（Composite Reuse Principle）
　　
　　原则是尽量使用合成/聚合的方式，而不是使用继承。　　

　　下面我们首先介绍工厂方法模式

　　参考[https://www.jianshu.com/p/d0c444275827](https://www.jianshu.com/p/d0c444275827)

----

# **简单工厂模式** #

　　简单工厂模式又叫静态方法模式，因为工厂类定义了一个静态方法。现实生活中，工厂是负责生产产品的；同样在设计模式中，简单工厂模式我们可以理解为负责生产对象的一个类，称为“工厂类”。

　　简单工厂模式要解决的问题简单来说就是，将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

　　**即使用者可直接消费产品而不需要知道其生产的细节**

　　该模式有三个组成成分，分别是抽象产品、具体产品、工厂

　　抽象产品：是具体产品的父亲，用来描述产品的公共接口

　　具体产品：抽象产品的子类，也是工厂类创建的目标类，它用来描述生产的具体产品

　　工厂：被外界调用的类，能根据传入的不同参数从而创建不同的具体产品类的实例

　　这个设计模式，可以说是我平时用的比较多的，像是消息系统里定义不同的消息类型、实体处理过程中不同的属性捕捉器等等都是用该设计模式实现

　　它的优点就是：将创建实例的工作与使用实例的工作分开，使用者不必关心类的对象如何创建，实现了解耦；把初始化实例的工作放到工厂里进行，是代码更容易维护。更符合面向对象的原则，是面向接口编程而不是面向实现编程。

　　但它也有缺点：

　　1. 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
　　2. 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。
　　3. 简单工厂模式由于使用了静态工厂方法，静态方法不能被继承和重写，会造成工厂角色无法形成基于继承的等级结构。
　　
# **工厂方法模式** #
　　
　　工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象。

　　刚刚我们了解了简单工厂模式，那么工厂方法模式的区别就在于，他并不是用一个工厂类去实例化所有产品类，而是有一个抽象的工厂类，然后所有的产品类都由对应的工厂类的子类去实例化，也就是说在原先的三个角色的基础上变成了四个角色：抽象工厂、具体工厂、抽象产品、具体产品

　　为什么要这样设计呢？

　　因为我们知道简单工厂模式未被了开闭原则，如果新增了一个产品类需要被实例化，我们就得改工厂类。如果使用工厂方法模式，我们不需要修改抽象工厂类，只需要新增一个工厂子类即可。（但这样又会带来其他的问题，后面介绍）

　　下面举个例子来说明下：

　　步骤1： 创建抽象工厂类，定义具体工厂的公共接口

	abstract class Factory{
    	public abstract Product Manufacture();
	}

　　步骤2： 创建抽象产品类 ，定义具体产品的公共接口；

	abstract class Product{
    	public abstract void Show();
	}

　　步骤3： 创建具体产品类（继承抽象产品类）， 定义生产的具体产品；

	//具体产品A类
	class  ProductA extends  Product{
    	@Override
    	public void Show() {
        	System.out.println("生产出了产品A");
    	}
	}

	//具体产品B类
	class  ProductB extends  Product{
    	@Override
    	public void Show() {
        	System.out.println("生产出了产品B");
    	}
	}

　　步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；

	//工厂A类 - 生产A类产品
	class  FactoryA extends Factory{
    	@Override
    	public Product Manufacture() {
        	return new ProductA();
    	}
	}

	//工厂B类 - 生产B类产品
	class  FactoryB extends Factory{
    	@Override
    	public Product Manufacture() {
        	return new ProductB();
    	}
	}

　　步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例

	//生产工作流程
	public class FactoryPattern {
    	public static void main(String[] args){
        	//客户要产品A
        	FactoryA mFactoryA = new FactoryA();
        	mFactoryA.Manufacture().Show();

        	//客户要产品B
        	FactoryB mFactoryB = new FactoryB();
        	mFactoryB.Manufacture().Show();
    	}
	}

　　**优点：**

　　更符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可，简单工厂模式需要修改工厂类的判断逻辑

　　符合单一职责原则：每个具体工厂类只负责创建对应的产品，简单工厂中的工厂类存在复杂的switch逻辑判断

　　不使用静态工厂方法，可以形成基于继承的等级结构。简单工厂模式的工厂类使用静态工厂方法

　　**缺点：**

　　复杂性增加，在添加新的产品类时，我们还要添加对应的工厂类

　　虽然工厂方法内满足了开闭原则，即在增加新产品类时不需要修改工厂方法，但是在使用工厂方法的类中，如果需要更换另外一种产品，还是需要修改代码 ，实例化其他的工厂类

　　一个具体的工厂只能创建一种具体产品